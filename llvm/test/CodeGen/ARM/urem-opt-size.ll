; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; When optimising for minimum size, we don't want to expand a div to a mul
; and a shift sequence. As a result, the urem instruction e.g. will not be
; expanded to a sequence of umull, lsrs, muls and sub instructions, but
; just a call to __aeabi_uidivmod.
;
; When the processor features hardware division, UDIV + UREM can be turned
; into UDIV + MLS. This prevents the library function __aeabi_uidivmod to be
; pulled into the binary. The test uses ARMv7-M.
;
; RUN: llc -mtriple=armv7a-eabi -mattr=-neon -verify-machineinstrs %s -o - | FileCheck %s
; RUN: llc -mtriple=thumbv7m-eabi -verify-machineinstrs %s -o - | FileCheck %s -check-prefix=V7M

target datalayout = "e-m:e-p:32:32-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "thumbv7m-arm-none-eabi"

define i32 @foo1() local_unnamed_addr #0 {
; CHECK-LABEL: foo1:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    bl GetValue
; CHECK-NEXT:    movw r1, #16960
; CHECK-NEXT:    movt r1, #15
; CHECK-NEXT:    pop {r11, lr}
; CHECK-NEXT:    b __aeabi_idiv
;
; V7M-LABEL: foo1:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    bl GetValue
; V7M-NEXT:    ldr r1, .LCPI0_0
; V7M-NEXT:    sdiv r0, r0, r1
; V7M-NEXT:    pop {r7, pc}
; V7M-NEXT:    .p2align 2
; V7M-NEXT:  @ %bb.1:
; V7M-NEXT:  .LCPI0_0:
; V7M-NEXT:    .long 1000000 @ 0xf4240
entry:
  %call = tail call i32 bitcast (i32 (...)* @GetValue to i32 ()*)()
  %div = sdiv i32 %call, 1000000
  ret i32 %div
}

define i32 @foo2() local_unnamed_addr #0 {
; CHECK-LABEL: foo2:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    bl GetValue
; CHECK-NEXT:    movw r1, #16960
; CHECK-NEXT:    movt r1, #15
; CHECK-NEXT:    pop {r11, lr}
; CHECK-NEXT:    b __aeabi_uidiv
;
; V7M-LABEL: foo2:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    bl GetValue
; V7M-NEXT:    ldr r1, .LCPI1_0
; V7M-NEXT:    udiv r0, r0, r1
; V7M-NEXT:    pop {r7, pc}
; V7M-NEXT:    .p2align 2
; V7M-NEXT:  @ %bb.1:
; V7M-NEXT:  .LCPI1_0:
; V7M-NEXT:    .long 1000000 @ 0xf4240
entry:
  %call = tail call i32 bitcast (i32 (...)* @GetValue to i32 ()*)()
  %div = udiv i32 %call, 1000000
  ret i32 %div
}

; Test for unsigned remainder
define i32 @foo3() local_unnamed_addr #0 {
; CHECK-LABEL: foo3:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    bl GetValue
; CHECK-NEXT:    movw r1, #16960
; CHECK-NEXT:    movt r1, #15
; CHECK-NEXT:    bl __aeabi_uidivmod
; CHECK-NEXT:    clz r0, r1
; CHECK-NEXT:    lsr r0, r0, #5
; CHECK-NEXT:    pop {r11, pc}
;
; V7M-LABEL: foo3:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    bl GetValue
; V7M-NEXT:    ldr r1, .LCPI2_0
; V7M-NEXT:    udiv r2, r0, r1
; V7M-NEXT:    mls r0, r2, r1, r0
; V7M-NEXT:    clz r0, r0
; V7M-NEXT:    lsrs r0, r0, #5
; V7M-NEXT:    pop {r7, pc}
; V7M-NEXT:    .p2align 2
; V7M-NEXT:  @ %bb.1:
; V7M-NEXT:  .LCPI2_0:
; V7M-NEXT:    .long 1000000 @ 0xf4240
entry:
  %call = tail call i32 bitcast (i32 (...)* @GetValue to i32 ()*)()
  %rem = urem i32 %call, 1000000
  %cmp = icmp eq i32 %rem, 0
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

; Test for signed remainder
define i32 @foo4() local_unnamed_addr #0 {
; CHECK-LABEL: foo4:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    bl GetValue
; CHECK-NEXT:    movw r1, #16960
; CHECK-NEXT:    movt r1, #15
; CHECK-NEXT:    bl __aeabi_idivmod
; CHECK-NEXT:    mov r0, r1
; CHECK-NEXT:    pop {r11, pc}
;
; V7M-LABEL: foo4:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    bl GetValue
; V7M-NEXT:    ldr r1, .LCPI3_0
; V7M-NEXT:    sdiv r2, r0, r1
; V7M-NEXT:    mls r0, r2, r1, r0
; V7M-NEXT:    pop {r7, pc}
; V7M-NEXT:    .p2align 2
; V7M-NEXT:  @ %bb.1:
; V7M-NEXT:  .LCPI3_0:
; V7M-NEXT:    .long 1000000 @ 0xf4240
entry:
  %call = tail call i32 bitcast (i32 (...)* @GetValue to i32 ()*)()
  %rem = srem i32 %call, 1000000
  ret i32 %rem
}

; Check that doing a sdiv+srem has the same effect as only the srem,
; as the division needs to be computed anyway in order to calculate
; the remainder (i.e. make sure we don't end up with two divisions).
define i32 @foo5() local_unnamed_addr #0 {
; CHECK-LABEL: foo5:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    bl GetValue
; CHECK-NEXT:    movw r1, #16960
; CHECK-NEXT:    movt r1, #15
; CHECK-NEXT:    bl __aeabi_idivmod
; CHECK-NEXT:    add r0, r0, r1
; CHECK-NEXT:    pop {r11, pc}
;
; V7M-LABEL: foo5:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    bl GetValue
; V7M-NEXT:    ldr r1, .LCPI4_0
; V7M-NEXT:    sdiv r2, r0, r1
; V7M-NEXT:    mls r0, r2, r1, r0
; V7M-NEXT:    add r0, r2
; V7M-NEXT:    pop {r7, pc}
; V7M-NEXT:    .p2align 2
; V7M-NEXT:  @ %bb.1:
; V7M-NEXT:  .LCPI4_0:
; V7M-NEXT:    .long 1000000 @ 0xf4240
entry:
  %call = tail call i32 bitcast (i32 (...)* @GetValue to i32 ()*)()
  %div = sdiv i32 %call, 1000000
  %rem = srem i32 %call, 1000000
  %add = add i32 %div, %rem
  ret i32 %add
}

; An early version of this patch caused isel to hang. The reason
; was that it shouldn't do the rewrite for i64 because that's not
; supported by hardware. Isel was stuck in a loop with type
; legalization and this optimisation.
; Function Attrs: norecurse nounwind
define i64 @isel_dont_hang(i32 %bar) local_unnamed_addr #4 {
; CHECK-LABEL: isel_dont_hang:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    .save {r11, lr}
; CHECK-NEXT:    push {r11, lr}
; CHECK-NEXT:    .setfp r11, sp
; CHECK-NEXT:    mov r11, sp
; CHECK-NEXT:    asr r1, r0, #31
; CHECK-NEXT:    adds r2, r0, #2
; CHECK-NEXT:    adc r3, r1, #0
; CHECK-NEXT:    lsl r1, r1, #1
; CHECK-NEXT:    orr r1, r1, r0, lsr #31
; CHECK-NEXT:    lsl r0, r0, #1
; CHECK-NEXT:    bl __aeabi_uldivmod
; CHECK-NEXT:    pop {r11, pc}
;
; V7M-LABEL: isel_dont_hang:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    .save {r7, lr}
; V7M-NEXT:    push {r7, lr}
; V7M-NEXT:    .setfp r7, sp
; V7M-NEXT:    mov r7, sp
; V7M-NEXT:    asrs r1, r0, #31
; V7M-NEXT:    adds r2, r0, #2
; V7M-NEXT:    adc r3, r1, #0
; V7M-NEXT:    lsl.w r1, r1, #1
; V7M-NEXT:    orr.w r1, r1, r0, lsr #31
; V7M-NEXT:    lsl.w r0, r0, #1
; V7M-NEXT:    bl __aeabi_uldivmod
; V7M-NEXT:    pop {r7, pc}
entry:
  %temp.0 = sext i32 %bar to i64
  %mul83 = shl i64 %temp.0, 1
  %add84 = add i64 %temp.0, 2
  %div85 = udiv i64 %mul83, %add84
  ret i64 %div85
}

; i16 types are promoted to i32, and we expect a normal udiv here:
define i16 @isel_dont_hang_2(i16 %bar) local_unnamed_addr #4 {
; CHECK-LABEL: isel_dont_hang_2:
; CHECK:       @ %bb.0: @ %entry
; CHECK-NEXT:    add r1, r0, #2
; CHECK-NEXT:    lsl r0, r0, #1
; CHECK-NEXT:    uxth r1, r1
; CHECK-NEXT:    uxth r0, r0
; CHECK-NEXT:    udiv r0, r0, r1
; CHECK-NEXT:    bx lr
;
; V7M-LABEL: isel_dont_hang_2:
; V7M:       @ %bb.0: @ %entry
; V7M-NEXT:    adds r1, r0, #2
; V7M-NEXT:    lsl.w r0, r0, #1
; V7M-NEXT:    uxth r1, r1
; V7M-NEXT:    uxth r0, r0
; V7M-NEXT:    udiv r0, r0, r1
; V7M-NEXT:    bx lr
entry:
  %mul83 = shl i16 %bar, 1
  %add84 = add i16 %bar, 2
  %div85 = udiv i16 %mul83, %add84
  ret i16 %div85
}
declare i32 @GetValue(...) local_unnamed_addr

attributes #0 = { minsize nounwind optsize }
attributes #4 = { norecurse nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-jump-tables"="false" "stack-protector-buffer-size"="8" "target-cpu"="cortex-a15" "target-features"="+dsp,+hwdiv,+hwdiv-arm,+neon,+vfp4" "use-soft-float"="false" }

